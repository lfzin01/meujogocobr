<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Snake Evolution | Portfólio</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* (mantive seu CSS praticamente igual; se quiser, posso reduzir aqui) */
        * { margin:0; padding:0; box-sizing:border-box; }
        :root {
            --primary: #00ff88; --primary-dark: #00cc66; --secondary: #00ccff;
            --accent:#ff44aa; --dark:#0a0a16; --darker:#050510; --light:#ffffff;
            --gray:#a0a0c0; --card-bg: rgba(20,20,40,0.7); --glass-bg: rgba(255,255,255,0.05);
            --glass-border: rgba(255,255,255,0.1); --transition: all 0.3s cubic-bezier(0.25,0.46,0.45,0.94);
        }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg,var(--darker) 0%,var(--dark) 100%); color:var(--light); min-height:100vh; }
        body::before { content:''; position:fixed; top:0; left:0; width:100%; height:100%; background:
            radial-gradient(circle at 20% 80%, rgba(0,255,136,0.1) 0%, transparent 50%),
            radial-gradient(circle at 80% 20%, rgba(0,204,255,0.1) 0%, transparent 50%),
            radial-gradient(circle at 40% 40%, rgba(255,68,170,0.05) 0%, transparent 50%);
            z-index:-1;
        }
        .container { max-width:1400px; margin:0 auto; padding:20px; display:flex; flex-direction:column; min-height:100vh; }
        header { display:flex; justify-content:space-between; align-items:center; padding:20px 0; margin-bottom:30px; border-bottom:1px solid var(--glass-border); }
        .logo { display:flex; align-items:center; gap:15px; }
        .logo-icon { font-size:2.5rem; color:var(--primary); filter: drop-shadow(0 0 5px var(--primary)); animation:pulse 2s infinite alternate; }
        @keyframes pulse { 0%{ transform:scale(1) } 100%{ transform:scale(1.1) } }
        .logo h1 { font-size:2.2rem; background: linear-gradient(90deg,var(--primary),var(--secondary)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; font-weight:800; }
        .theme-toggle { background:var(--glass-bg); border:1px solid var(--glass-border); border-radius:50px; padding:10px 20px; color:var(--light); cursor:pointer; display:flex; gap:10px; align-items:center; transition:var(--transition); backdrop-filter: blur(10px); }
        .main-content { display:grid; grid-template-columns: 1fr 2fr; gap:30px; flex:1; }
        @media (max-width:1100px){ .main-content { grid-template-columns: 1fr; } }
        .game-panel { background:var(--card-bg); border-radius:20px; padding:25px; backdrop-filter: blur(10px); border:1px solid var(--glass-border); box-shadow:0 10px 30px rgba(0,0,0,0.3); display:flex; flex-direction:column; gap:25px; }
        .panel-section { background:var(--glass-bg); border-radius:15px; padding:20px; border:1px solid var(--glass-border); }
        .section-title { display:flex; align-items:center; gap:10px; margin-bottom:15px; color:var(--primary); font-size:1.2rem; }
        .score-container { display:flex; gap:15px; }
        .score-card { flex:1; background: linear-gradient(135deg, rgba(0,255,136,0.1), rgba(0,204,255,0.1)); border-radius:12px; padding:15px; text-align:center; border:1px solid rgba(0,255,136,0.2); }
        .score-value { font-size:2rem; font-weight:700; color:var(--primary); text-shadow: 0 0 10px rgba(0,255,136,0.5); }
        .controls-grid { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
        .btn { padding:14px; border:none; border-radius:12px; font-weight:600; cursor:pointer; display:flex; align-items:center; justify-content:center; gap:8px; }
        .btn-primary { background: linear-gradient(135deg, var(--primary), var(--primary-dark)); color:var(--darker); box-shadow: 0 4px 15px rgba(0,255,136,0.3); }
        .btn-secondary { background:var(--glass-bg); color:var(--light); border:1px solid var(--glass-border); }
        .game-area { display:flex; flex-direction:column; gap:25px; }
        .game-display { background: var(--card-bg); border-radius:20px; overflow:hidden; backdrop-filter: blur(10px); border:1px solid var(--glass-border); box-shadow:0 10px 30px rgba(0,0,0,0.3); position:relative; flex:1; display:flex; justify-content:center; align-items:center; min-height:500px; }
        #game-canvas { display:block; background:var(--darker); border-radius:10px; max-width:100%; box-shadow: inset 0 0 20px rgba(0,0,0,0.5); }
        .screen { position:absolute; top:0; left:0; width:100%; height:100%; display:flex; flex-direction:column; justify-content:center; align-items:center; background: rgba(5,5,16,0.95); z-index:10; text-align:center; padding:30px; }
        .screen h2 { font-size:3rem; margin-bottom:20px; background: linear-gradient(90deg,var(--primary),var(--secondary)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
        .hidden { display:none !important; }
        .mobile-controls { display:none; grid-template-areas: ". up ." "left down right"; grid-template-columns:1fr 1fr 1fr; grid-template-rows:1fr 1fr; gap:15px; padding:20px; background:var(--card-bg); border-radius:20px; backdrop-filter: blur(10px); border:1px solid var(--glass-border); }
        @media (max-width:768px){ .mobile-controls { display:grid; } }
        .control-btn { width:70px; height:70px; border-radius:50%; background:var(--glass-bg); color:var(--light); border:1px solid var(--glass-border); font-size:1.8rem; display:flex; justify-content:center; align-items:center; cursor:pointer; transition:var(--transition); }
        footer { margin-top:40px; text-align:center; padding:20px 0; border-top:1px solid var(--glass-border); color:var(--gray); font-size:0.9rem; }
        .fade-in { animation: fadeIn 0.8s ease-out; }
        @keyframes fadeIn { from{ opacity:0; transform:translateY(20px); } to{ opacity:1; transform:translateY(0); } }
        body.light-theme { --dark:#f0f2f5; --darker:#ffffff; --light:#333344; --gray:#666688; --card-bg: rgba(255,255,255,0.7); --glass-bg: rgba(255,255,255,0.5); --glass-border: rgba(0,0,0,0.1); background: linear-gradient(135deg,#e0e5ec 0%,#f0f2f5 100%); }
        .error-boundary { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:9999; color:white; padding:20px; text-align:center; display:flex; flex-direction:column; justify-content:center; align-items:center; }
    </style>
</head>
<body>
    <!-- Error Boundary -->
    <div id="error-boundary" class="error-boundary hidden">
        <h2>⚠️ Erro no Jogo</h2>
        <p id="error-message">Ocorreu um erro ao carregar o jogo. Por favor, recarregue a página.</p>
        <button onclick="window.location.reload()" class="btn btn-primary" style="margin-top:20px;">Recarregar Página</button>
    </div>

    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon"><i class="fas fa-gamepad"></i></div>
                <div class="logo-text">
                    <h1>Snake Evolution</h1>
                    <p>A Serpente Definitiva</p>
                </div>
            </div>
            <button class="theme-toggle" id="theme-toggle"><i class="fas fa-moon"></i> <span>Modo Escuro</span></button>
        </header>

        <div class="main-content">
            <div class="game-panel fade-in">
                <div class="panel-section">
                    <div class="section-title"><i class="fas fa-chart-line"></i><h3>Pontuação</h3></div>
                    <div class="score-container">
                        <div class="score-card"><div class="score-label">Score</div><div class="score-value" id="score">0</div></div>
                        <div class="score-card"><div class="score-label">High Score</div><div class="score-value" id="high-score">0</div></div>
                    </div>
                </div>

                <div class="panel-section">
                    <div class="section-title"><i class="fas fa-play-circle"></i><h3>Controles</h3></div>
                    <div class="controls-grid">
                        <button id="start-btn" class="btn btn-primary"><i class="fas fa-play"></i> Iniciar</button>
                        <button id="pause-btn" class="btn btn-secondary"><i class="fas fa-pause"></i> Pausar</button>
                        <button id="restart-btn" class="btn btn-secondary"><i class="fas fa-redo"></i> Reiniciar</button>
                        <button id="sound-toggle" class="btn btn-secondary"><i class="fas fa-volume-up"></i> Som</button>
                    </div>
                </div>

                <div class="panel-section">
                    <div class="section-title"><i class="fas fa-cogs"></i><h3>Configurações</h3></div>
                    <div class="settings-grid">
                        <div class="setting-group">
                            <div class="setting-label"><i class="fas fa-tachometer-alt"></i> Velocidade</div>
                            <div class="select-wrapper">
                                <select id="speed-select">
                                    <option value="slow">Lento</option>
                                    <option value="normal" selected>Normal</option>
                                    <option value="fast">Rápido</option>
                                </select>
                            </div>
                        </div>
                        <div class="setting-group">
                            <div class="setting-label"><i class="fas fa-border-all"></i> Modo Parede</div>
                            <div class="select-wrapper">
                                <select id="wall-mode">
                                    <option value="with-walls" selected>Com Parede</option>
                                    <option value="without-walls">Sem Parede</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="panel-section">
                    <div class="section-title"><i class="fas fa-info-circle"></i><h3>Instruções</h3></div>
                    <div class="instructions">
                        <p>Use as <strong>setas do teclado</strong> para controlar a cobra.</p>
                        <p>Coma a <strong>comida vermelha</strong> para crescer e ganhar pontos.</p>
                        <p>Evite colidir com as <strong>paredes</strong> e com seu <strong>próprio corpo</strong>.</p>
                        <p>Colete <strong>power-ups dourados</strong> para ganhar bônus!</p>
                    </div>
                </div>
            </div>

            <div class="game-area">
                <div class="game-display">
                    <canvas id="game-canvas" width="600" height="600"></canvas>

                    <div id="start-screen" class="screen">
                        <h2>Snake Evolution</h2>
                        <p>Um jogo clássico reinventado com visual moderno</p>
                        <p>Use as setas do teclado para controlar a cobra</p>
                        <p>Coma a comida para crescer e ganhar pontos</p>
                        <p>Evite colidir com as paredes e com seu próprio corpo</p>
                        <button id="play-btn" class="btn btn-primary" style="margin-top:30px; padding:15px 30px;"><i class="fas fa-play"></i> Jogar Agora</button>
                    </div>

                    <div id="game-over-screen" class="screen hidden">
                        <h2>Game Over</h2>
                        <p>Sua pontuação: <span id="final-score">0</span></p>
                        <p>Recorde: <span id="final-high-score">0</span></p>
                        <button id="play-again-btn" class="btn btn-primary" style="margin-top:30px; padding:15px 30px;"><i class="fas fa-redo"></i> Jogar Novamente</button>
                    </div>
                </div>

                <div id="mobile-controls" class="mobile-controls">
                    <button id="up-btn" class="control-btn">↑</button>
                    <button id="left-btn" class="control-btn">←</button>
                    <button id="down-btn" class="control-btn">↓</button>
                    <button id="right-btn" class="control-btn">→</button>
                </div>
            </div>
        </div>

        <footer class="fade-in"><p>Snake Evolution &copy; 2023 - Desenvolvido para Portfólio</p></footer>
    </div>

    <!-- Efeitos sonoros simplificados (data URIs seguros) -->
    <audio id="eat-sound" preload="auto">
        <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
    </audio>
    <audio id="game-over-sound" preload="auto">
        <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
    </audio>

    <script>
    // Configurações iniciais do jogo
    const GameConfig = {
        GRID_SIZE: 20,
        INITIAL_SPEED: 150,
        INITIAL_SNAKE_LENGTH: 3,
        SOUND_ENABLED: true,
        THEME: 'dark'
    };

    // Referências serão definidas dentro de initGame() para evitar nulls
    let elements = null;

    // Estado do jogo
    const gameState = {
        snake: [],
        food: { x: 0, y: 0 },
        direction: 'right',
        nextDirection: 'right',
        score: 0,
        highScore: 0,
        gameLoop: null,
        isPaused: true,
        isGameOver: false,
        gridWidth: 0,
        gridHeight: 0,
        speed: GameConfig.INITIAL_SPEED,
        powerUp: null,
        powerUpTimer: 0
    };

    // Captura erros não tratados e exibe o error-boundary
    window.addEventListener('error', function (e) {
        console.error('Erro capturado (window.error):', e.error || e.message || e);
        showErrorBoundary(e.error ? (e.error.message || String(e.error)) : String(e.message || e));
    });

    // Captura promessas rejeitadas
    window.addEventListener('unhandledrejection', function (e) {
        console.error('Unhandled Rejection:', e.reason);
        showErrorBoundary(e.reason ? (e.reason.message || String(e.reason)) : String(e.reason));
    });

    function showErrorBoundary(message) {
        try {
            const boundary = document.getElementById('error-boundary');
            const msg = document.getElementById('error-message');
            if (msg) msg.textContent = message || 'Ocorreu um erro ao carregar o jogo.';
            if (boundary) boundary.classList.remove('hidden');
        } catch (e) {
            console.error('Falha ao mostrar error boundary:', e);
        }
    }

    function initGame() {
        try {
            // Buscando elementos DOM aqui (depois do carregamento)
            elements = {
                canvas: document.getElementById('game-canvas'),
                ctx: null,
                score: document.getElementById('score'),
                highScore: document.getElementById('high-score'),
                startBtn: document.getElementById('start-btn'),
                pauseBtn: document.getElementById('pause-btn'),
                restartBtn: document.getElementById('restart-btn'),
                speedSelect: document.getElementById('speed-select'),
                wallMode: document.getElementById('wall-mode'),
                soundToggle: document.getElementById('sound-toggle'),
                themeToggle: document.getElementById('theme-toggle'),
                startScreen: document.getElementById('start-screen'),
                gameOverScreen: document.getElementById('game-over-screen'),
                playBtn: document.getElementById('play-btn'),
                playAgainBtn: document.getElementById('play-again-btn'),
                finalScore: document.getElementById('final-score'),
                finalHighScore: document.getElementById('final-high-score'),
                mobileControls: document.getElementById('mobile-controls'),
                upBtn: document.getElementById('up-btn'),
                downBtn: document.getElementById('down-btn'),
                leftBtn: document.getElementById('left-btn'),
                rightBtn: document.getElementById('right-btn'),
                eatSound: document.getElementById('eat-sound'),
                gameOverSound: document.getElementById('game-over-sound')
            };

            // Verificações mínimas — se algum elemento essencial estiver faltando, mostra erro
            if (!elements.canvas || !elements.score || !elements.highScore || !elements.startBtn) {
                throw new Error('Elementos essenciais não encontrados no DOM. Verifique se o HTML contém os IDs corretos.');
            }

            // Configurar contexto do canvas
            elements.ctx = elements.canvas.getContext('2d');
            if (!elements.ctx) throw new Error('Canvas context não suportado ou não encontrado.');

            // Eventos básicos
            window.addEventListener('resize', resizeCanvas);
            document.addEventListener('keydown', handleKeyDown);

            // Botões e controles (checando existência antes de adicionar listener)
            elements.startBtn && elements.startBtn.addEventListener('click', startGame);
            elements.pauseBtn && elements.pauseBtn.addEventListener('click', pauseGame);
            elements.restartBtn && elements.restartBtn.addEventListener('click', restartGame);
            elements.playBtn && elements.playBtn.addEventListener('click', startGame);
            elements.playAgainBtn && elements.playAgainBtn.addEventListener('click', restartGame);
            elements.speedSelect && elements.speedSelect.addEventListener('change', updateSpeed);
            elements.wallMode && elements.wallMode.addEventListener('change', updateWallMode);
            elements.soundToggle && elements.soundToggle.addEventListener('click', toggleSound);
            elements.themeToggle && elements.themeToggle.addEventListener('click', toggleTheme);

            elements.upBtn && elements.upBtn.addEventListener('click', () => changeDirection('up'));
            elements.downBtn && elements.downBtn.addEventListener('click', () => changeDirection('down'));
            elements.leftBtn && elements.leftBtn.addEventListener('click', () => changeDirection('left'));
            elements.rightBtn && elements.rightBtn.addEventListener('click', () => changeDirection('right'));

            // Tentar recuperar highscore do localStorage com proteção (alguns ambientes bloqueiam)
            try {
                const stored = localStorage.getItem('snakeHighScore');
                gameState.highScore = stored ? parseInt(stored, 10) || 0 : 0;
            } catch (e) {
                console.warn('localStorage inacessível:', e);
                gameState.highScore = 0;
            }

            elements.highScore.textContent = gameState.highScore;
            elements.finalHighScore.textContent = gameState.highScore;

            // Exibe tela inicial
            drawStartScreen();

            // Inicializa speed a partir do select (garante coerência)
            updateSpeed();

            console.log('Jogo inicializado com sucesso!');
        } catch (error) {
            console.error('Erro na inicialização:', error);
            showErrorBoundary(error.message || String(error));
        }
    }

    function resizeCanvas() {
        try {
            if (!elements || !elements.canvas) return;
            const container = elements.canvas.parentElement;
            const size = Math.min(container.clientWidth, container.clientHeight) * 0.8;
            const gridSize = GameConfig.GRID_SIZE;
            const width = Math.floor(size / gridSize) * gridSize;
            const height = width;
            elements.canvas.width = width || 600;
            elements.canvas.height = height || 600;
            gameState.gridWidth = Math.max(10, Math.floor(elements.canvas.width / gridSize));
            gameState.gridHeight = Math.max(10, Math.floor(elements.canvas.height / gridSize));

            if (!gameState.isPaused && !gameState.isGameOver) drawGame();
            else if (gameState.isGameOver) drawGameOverScreen();
            else drawStartScreen();
        } catch (error) {
            console.error('Erro no resize:', error);
        }
    }

    function drawStartScreen() {
        try {
            if (!elements || !elements.ctx) return;
            const ctx = elements.ctx;
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, elements.canvas.width, elements.canvas.height);
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SNAKE EVOLUTION', elements.canvas.width / 2, elements.canvas.height / 2 - 50);
            ctx.fillStyle = '#a0a0c0';
            ctx.font = '16px Arial';
            ctx.fillText('Use as setas para controlar a cobra', elements.canvas.width / 2, elements.canvas.height / 2 + 20);
            // garante que start screen HTML esteja visível
            elements.startScreen && elements.startScreen.classList.remove('hidden');
        } catch (error) {
            console.error('Erro ao desenhar tela inicial:', error);
        }
    }

    function startGame() {
        try {
            resetGame();
            elements.startScreen && elements.startScreen.classList.add('hidden');
            elements.gameOverScreen && elements.gameOverScreen.classList.add('hidden');
            gameState.isPaused = false;
            gameState.isGameOver = false;
            // atualiza texto do botão pausa
            if (elements.pauseBtn) elements.pauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pausar';
            startLoop();
        } catch (error) {
            console.error('Erro ao iniciar jogo:', error);
        }
    }

    function resetGame() {
        try {
            gameState.snake = [];
            const startX = Math.floor(gameState.gridWidth / 2);
            const startY = Math.floor(gameState.gridHeight / 2);
            for (let i = 0; i < GameConfig.INITIAL_SNAKE_LENGTH; i++) {
                gameState.snake.push({ x: startX - i, y: startY });
            }
            gameState.direction = 'right';
            gameState.nextDirection = 'right';
            gameState.score = 0;
            elements.score && (elements.score.textContent = '0');
            generateFood();
            gameState.powerUp = null;
            updateSpeed();
        } catch (error) {
            console.error('Erro no reset:', error);
        }
    }

    // renamed internal loop runner para startLoop para evitar ambiguidade
    function startLoop() {
        try {
            clearInterval(gameState.gameLoop);
            gameState.gameLoop = setInterval(() => {
                if (!gameState.isPaused && !gameState.isGameOver) {
                    updateGame();
                    drawGame();
                }
            }, gameState.speed);
        } catch (error) {
            console.error('Erro no game loop:', error);
        }
    }

    function updateGame() {
        try {
            gameState.direction = gameState.nextDirection;
            const head = { ...gameState.snake[0] };
            switch (gameState.direction) {
                case 'up': head.y -= 1; break;
                case 'down': head.y += 1; break;
                case 'left': head.x -= 1; break;
                case 'right': head.x += 1; break;
            }

            // colisões com parede/teleporte
            const wallMode = (elements && elements.wallMode && elements.wallMode.value) || 'with-walls';
            if (wallMode === 'with-walls') {
                if (head.x < 0 || head.x >= gameState.gridWidth || head.y < 0 || head.y >= gameState.gridHeight) {
                    gameOver();
                    return;
                }
            } else {
                if (head.x < 0) head.x = gameState.gridWidth - 1;
                if (head.x >= gameState.gridWidth) head.x = 0;
                if (head.y < 0) head.y = gameState.gridHeight - 1;
                if (head.y >= gameState.gridHeight) head.y = 0;
            }

            for (let i = 0; i < gameState.snake.length; i++) {
                if (head.x === gameState.snake[i].x && head.y === gameState.snake[i].y) {
                    gameOver();
                    return;
                }
            }

            gameState.snake.unshift(head);

            if (head.x === gameState.food.x && head.y === gameState.food.y) {
                gameState.score += 10;
                elements.score && (elements.score.textContent = gameState.score);

                if (gameState.score > gameState.highScore) {
                    gameState.highScore = gameState.score;
                    elements.highScore && (elements.highScore.textContent = gameState.highScore);
                    try {
                        localStorage.setItem('snakeHighScore', gameState.highScore.toString());
                    } catch (e) {
                        console.warn('Não foi possível salvar no localStorage');
                    }
                }

                if (GameConfig.SOUND_ENABLED) playEatSound();
                generateFood();
            } else {
                gameState.snake.pop();
            }
        } catch (error) {
            console.error('Erro no update:', error);
        }
    }

    function drawGame() {
        try {
            if (!elements || !elements.ctx) return;
            const ctx = elements.ctx;
            const size = GameConfig.GRID_SIZE;
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, elements.canvas.width, elements.canvas.height);

            // grade
            ctx.strokeStyle = 'rgba(160,160,192,0.1)';
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= elements.canvas.width; x += size) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, elements.canvas.height); ctx.stroke();
            }
            for (let y = 0; y <= elements.canvas.height; y += size) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(elements.canvas.width, y); ctx.stroke();
            }

            // cobra
            gameState.snake.forEach((segment, index) => {
                if (index === 0) ctx.fillStyle = '#00ff88';
                else {
                    const colorValue = Math.max(50, 200 - index * 5);
                    ctx.fillStyle = `rgb(0, ${colorValue}, 100)`;
                }
                ctx.fillRect(segment.x * size, segment.y * size, size, size);
            });

            // comida
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.arc(gameState.food.x * size + size / 2, gameState.food.y * size + size / 2, size / 2, 0, Math.PI * 2);
            ctx.fill();
        } catch (error) {
            console.error('Erro ao desenhar:', error);
        }
    }

    function drawGameOverScreen() {
        try {
            elements.finalScore && (elements.finalScore.textContent = gameState.score);
            elements.finalHighScore && (elements.finalHighScore.textContent = gameState.highScore);
            elements.gameOverScreen && elements.gameOverScreen.classList.remove('hidden');
        } catch (e) {
            console.error('Erro ao mostrar game over screen:', e);
        }
    }

    function generateFood() {
        try {
            let newFood, foodOnSnake;
            do {
                foodOnSnake = false;
                newFood = { x: Math.floor(Math.random() * gameState.gridWidth), y: Math.floor(Math.random() * gameState.gridHeight) };
                for (let segment of gameState.snake) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        foodOnSnake = true; break;
                    }
                }
            } while (foodOnSnake);
            gameState.food = newFood;
        } catch (error) {
            console.error('Erro ao gerar comida:', error);
        }
    }

    function gameOver() {
        try {
            gameState.isGameOver = true;
            clearInterval(gameState.gameLoop);
            if (GameConfig.SOUND_ENABLED) playGameOverSound();
            drawGameOverScreen();
        } catch (error) {
            console.error('Erro no game over:', error);
        }
    }

    function handleKeyDown(event) {
        try {
            if (!event) return;
            // Espaço => pausar/continuar; se for gameOver, reinicia
            if (event.code === 'Space') {
                event.preventDefault();
                if (gameState.isGameOver) { restartGame(); return; }
                pauseGame();
                return;
            }
            switch (event.code) {
                case 'ArrowUp': event.preventDefault(); changeDirection('up'); break;
                case 'ArrowDown': event.preventDefault(); changeDirection('down'); break;
                case 'ArrowLeft': event.preventDefault(); changeDirection('left'); break;
                case 'ArrowRight': event.preventDefault(); changeDirection('right'); break;
            }
        } catch (error) {
            console.error('Erro em handleKeyDown:', error);
        }
    }

    function changeDirection(newDirection) {
        if (
            (newDirection === 'up' && gameState.direction !== 'down') ||
            (newDirection === 'down' && gameState.direction !== 'up') ||
            (newDirection === 'left' && gameState.direction !== 'right') ||
            (newDirection === 'right' && gameState.direction !== 'left')
        ) {
            gameState.nextDirection = newDirection;
        }
    }

    function pauseGame() {
        try {
            gameState.isPaused = !gameState.isPaused;
            if (gameState.isPaused) {
                clearInterval(gameState.gameLoop);
                elements.pauseBtn && (elements.pauseBtn.innerHTML = '<i class="fas fa-play"></i> Continuar');
            } else {
                startLoop();
                elements.pauseBtn && (elements.pauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pausar');
            }
        } catch (error) {
            console.error('Erro ao pausar/continuar:', error);
        }
    }

    function restartGame() {
        try {
            clearInterval(gameState.gameLoop);
            // garantir tela inicial escondida
            elements.startScreen && elements.startScreen.classList.add('hidden');
            startGame();
        } catch (error) {
            console.error('Erro ao reiniciar:', error);
        }
    }

    function updateSpeed() {
        try {
            if (!elements || !elements.speedSelect) {
                gameState.speed = GameConfig.INITIAL_SPEED;
                return;
            }
            const speedValue = elements.speedSelect.value;
            switch (speedValue) {
                case 'slow': gameState.speed = 200; break;
                case 'normal': gameState.speed = 150; break;
                case 'fast': gameState.speed = 100; break;
                default: gameState.speed = GameConfig.INITIAL_SPEED;
            }
            if (!gameState.isPaused && !gameState.isGameOver) startLoop();
        } catch (error) {
            console.error('Erro ao atualizar velocidade:', error);
        }
    }

    function updateWallMode() { /* mantido para API */ }

    function toggleSound() {
        GameConfig.SOUND_ENABLED = !GameConfig.SOUND_ENABLED;
        if (!elements || !elements.soundToggle) return;
        if (GameConfig.SOUND_ENABLED) elements.soundToggle.innerHTML = '<i class="fas fa-volume-up"></i> Som';
        else elements.soundToggle.innerHTML = '<i class="fas fa-volume-mute"></i> Som';
    }

    function toggleTheme() {
        try {
            if (document.body.classList.contains('light-theme')) {
                document.body.classList.remove('light-theme');
                elements.themeToggle && (elements.themeToggle.innerHTML = '<i class="fas fa-moon"></i> Modo Escuro');
            } else {
                document.body.classList.add('light-theme');
                elements.themeToggle && (elements.themeToggle.innerHTML = '<i class="fas fa-sun"></i> Modo Claro');
            }
        } catch (error) {
            console.error('Erro ao alternar tema:', error);
        }
    }

    function playEatSound() {
        try {
            if (!elements || !elements.eatSound) return;
            elements.eatSound.currentTime = 0;
            elements.eatSound.play().catch(e => console.log('Áudio não pode ser reproduzido', e));
        } catch (e) { /* ignorar */ }
    }

    function playGameOverSound() {
        try {
            if (!elements || !elements.gameOverSound) return;
            elements.gameOverSound.currentTime = 0;
            elements.gameOverSound.play().catch(e => console.log('Áudio não pode ser reproduzido', e));
        } catch (e) { /* ignorar */ }
    }

    // Inicializar quando a página carregar
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initGame);
    } else {
        initGame();
    }
    </script>
</body>
</html>
